---
name: project-init
description: Generate project memory rules in docs/claude-rules/ for native Claude Code integration
allowed-tools: Read, Glob, Grep, LS, Write, Bash
---

# Project Initialization

Analyzes the project and generates modular rule files that Claude Code loads automatically.

**Purpose**: High-signal project memory preventing context-related failures
**Output**: 4 rule files (~140 lines total)

## Architecture

```
docs/claude-rules/        â† TRACKED (source of truth, versioned)
â”œâ”€â”€ stack.md
â”œâ”€â”€ patterns.md
â”œâ”€â”€ architecture.md
â””â”€â”€ testing.md (if tests exist)

.claude/rules/            â† IGNORED (local working copy)
â””â”€â”€ (auto-synced by session-start hook)
```

**Pattern**: Similar to `.env.example` â†’ `.env`
- Canonical rules live in `docs/claude-rules/` (reviewable in PRs)
- Session-start hook syncs to `.claude/rules/` automatically
- Team shares rules without polluting `.claude/` directory

## Benefits

- **Native loading**: Rules auto-loaded at same priority as CLAUDE.md
- **Modular**: Update one aspect without touching others
- **Richer context**: ~3x more useful information than legacy format
- **Team-shared**: Rules versioned in git, synced automatically

## Execution Flow

### Phase 1: Cleanup & Preparation

**1.1 Detect existing state:**

Check for existing rules or legacy context:
- `docs/claude-rules/*.md` - Existing tracked rules to replace
- `.claude/rules/*.md` - Local rules (will be overwritten by sync)
- `.specify/memory/project-context.md` - Legacy format to migrate

**1.2 Clean up old state (if exists):**

- If `docs/claude-rules/` exists with `.md` files â†’ Remove all `.md` files in that directory
- If `.specify/memory/project-context.md` exists â†’ Remove it
- Report: "ğŸ—‘ï¸ Cleaning up previous context..."

**1.3 Create rules directories:**

```bash
mkdir -p docs/claude-rules/
mkdir -p .claude/rules/
```

### Phase 2: Project Analysis

Execute all 5 layers to extract project context.

**Layer 1: Manifests (Read 100%)**

Glob and read package manager files:
- `package.json`, `package-lock.json` (deps section only)
- `pyproject.toml`, `requirements.txt`, `setup.py`
- `go.mod`, `Cargo.toml`, `Gemfile`, `composer.json`

Extract:
- Runtime version (engines, python_requires)
- Framework + version (main dependency)
- Top 5-7 dependencies by import frequency
- Available scripts (build, test, dev)

**Layer 2: Configs (Read 100%)**

Glob and read configuration files:
- `tsconfig.json`, `jsconfig.json`
- `.eslintrc*`, `.prettierrc*`, `biome.json`
- `.editorconfig`
- `pytest.ini`, `jest.config.*`, `vitest.config.*`
- `.env.example` (NOT `.env`)
- `docker-compose.yml`

Extract:
- Compiler/strict mode settings
- Formatting rules (tabs/spaces, quotes)
- Test framework configuration
- Expected environment variables

**Layer 3: Structure (LS + Glob)**

Analyze project structure:
- Top-level directories (depth 1)
- Entry points: `**/index.{ts,js,py}`, `**/main.{ts,js,py,go}`, `**/app.{ts,js,py}`
- File distribution per directory

Extract:
- Entry point file(s)
- Layer distribution (src/, lib/, api/)
- Major directories and their purpose

**Layer 4: Patterns (Grep targeted)**

Sample 5-10 matches for each pattern:

```
# Naming conventions
grep: "^(export )?(function|const|def|func) \w+"

# Error handling
grep: "(throw|raise|return err|new Error)"

# Import style
grep: "^(import|from|require)"

# Auth patterns
grep: "(@auth|@require|middleware.*auth|guard)"

# Test patterns
grep: "(describe|test|it|def test_)\("
```

Extract:
- Dominant naming convention (camelCase/snake_case/etc.)
- Error handling pattern
- Import style (ESM/CJS)
- Auth mechanism (if exists)

**Layer 5: Key File Sampling**

Read 5-8 representative files:

1. **Entry point** (always): `main.*`, `index.*`, `app.*`
2. **One file per major directory**: Select largest file in each of top 3-4 dirs
3. **One test file** (if tests exist): Any `*.test.*` or `*.spec.*`
4. **README.md** (if exists): First 50 lines only

Extract:
- Code style in practice (confirms grep findings)
- Framework idioms and patterns
- API type indicators (REST/GraphQL/gRPC)

### Phase 3: Synthesis â†’ Rule Files

Generate rule files from analysis data. Write each file to `docs/claude-rules/` (tracked), then copy to `.claude/rules/` (local).

**3.1 Generate stack.md**

```markdown
# Stack

**Runtime**: [detected runtime + version]
**Framework**: [main framework + version]
**Database**: [if detected]

## Critical Dependencies
- [dep1] [version] ([purpose])
- [dep2] [version] ([purpose])
- [dep3] [version] ([purpose])
- [dep4] [version] ([purpose])
- [dep5] [version] ([purpose])

## Scripts
- `[script1]` - [description]
- `[script2]` - [description]
- `[script3]` - [description]

---
*Auto-generated by /project-init on [DATE]*
```

**3.2 Generate patterns.md**

```markdown
# Patterns

## Naming Conventions
- Files: [convention] (`example`)
- Functions: [convention] (`example`)
- Types/Classes: [convention] (`example`)
- Constants: [convention] (`example`)

## Error Handling
- Pattern: [detected pattern]
- Location: [centralized handler if exists]

## Import Style
- [ESM/CJS/mixed]
- Relative: [pattern]
- Absolute: [pattern]

## Security Patterns
- Auth: [mechanism if detected]
- Validation: [approach if detected]

---
*Auto-generated by /project-init on [DATE]*
```

**3.3 Generate architecture.md**

```markdown
# Architecture

## Entry Point
`[path]` â†’ [description]

## Layer Structure
```
[dir1]/  # [purpose]
[dir2]/  # [purpose]
[dir3]/  # [purpose]
[dir4]/  # [purpose]
```

## API Type
[REST/GraphQL/gRPC/None detected]

## Data Flow
[Brief description of request flow if detectable]

---
*Auto-generated by /project-init on [DATE]*
```

**3.4 Generate testing.md (CONDITIONAL)**

Only generate if tests detected:
- `jest.config.*` exists, OR
- `pytest.ini` exists, OR
- `vitest.*` exists, OR
- `test*/` directory exists, OR
- `**/*.test.*` count > 3

```markdown
# Testing

## Framework
[detected framework]

## Conventions
- Location: [test directory structure]
- Naming: [pattern]
- Style: [detected patterns]

## Commands
- `[test command]` - Run tests
- `[coverage command]` - With coverage (if exists)

---
*Auto-generated by /project-init on [DATE]*
```

### Phase 4: Sync to Local & Report

**4.1 Copy to local .claude/rules/:**

After writing to `docs/claude-rules/`, copy all generated files to `.claude/rules/`:

```bash
cp docs/claude-rules/*.md .claude/rules/
```

**4.2 Display summary:**

```
ğŸ” Analyzing project...

ğŸ“¦ Stack detected:
   Runtime: [runtime + version]
   Framework: [framework + version]
   Database: [database or "None detected"]

ğŸ“ Patterns identified:
   Naming: [convention summary]
   Errors: [error pattern]
   Auth: [auth mechanism or "None detected"]

ğŸ—ï¸ Architecture:
   Entry: [entry point]
   Layers: [dir1], [dir2], [dir3]
   API: [type]

âœ… Generated docs/claude-rules/ (tracked):
   â€¢ stack.md ([N] lines)
   â€¢ patterns.md ([N] lines)
   â€¢ architecture.md ([N] lines)
   â€¢ testing.md ([N] lines)  â† only if generated

   Total: [N] lines of high-signal context

ğŸ“‹ Synced to .claude/rules/ (local working copy)

ğŸ—‘ï¸ Cleaned up:  â† only if cleanup occurred
   â€¢ Removed .specify/memory/project-context.md
   â€¢ Removed old docs/claude-rules/

ğŸ’¡ Rules flow:
   â€¢ docs/claude-rules/ â†’ commit to git (team-shared)
   â€¢ .claude/rules/ â†’ auto-synced on session start (local)
```

## Notes

- **Dual-location pattern**: `docs/claude-rules/` (tracked) + `.claude/rules/` (ignored)
- **Auto-sync**: Session-start hook copies tracked rules to local on every session
- **Team-shared**: Rules can be reviewed in PRs, shared across team
- **Auto-cleanup**: Removes legacy `project-context.md` if present
- **Full rebuild**: Always regenerates all rules (no incremental)
- **Conditional testing.md**: Only generated if tests detected
- **Token budget**: ~1,800 tokens for analysis, ~140 lines output
