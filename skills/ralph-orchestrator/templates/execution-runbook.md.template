# Execution Runbook

> **You are the ORCHESTRATOR.** Teammates implement — you coordinate.
> Read this file completely. Follow every instruction.
> **If your context was compressed**, re-read this file — it contains all orchestration instructions.

---

## 1. Team Configuration

<!-- Fill with concrete values from config.sh and goal derivation -->

- **Team name**: `ralph-{goal-slug}`
- **MAX_TEAMMATES**: (from config.sh)
- **Model**: (from config.sh)

## 2. Task Registry

<!-- One row per .code-task.md file. Paths must be absolute or repo-relative. -->

| Step | File | Blocked-By | Title |
|------|------|------------|-------|
<!-- Populate from .ralph/specs/{goal}/implementation/step*/*.code-task.md -->
<!-- Note: Blocked-By may include synthetic dependencies added by file overlap detection (Step 2c) -->

## 3. Quality Gates

<!-- Copy from .ralph/config.sh — only non-empty gates -->

| Gate | Command |
|------|---------|
<!-- e.g. GATE_TEST | node --test test/**/*.test.js -->

## 4. Launch Procedure

Execute these steps:

### 4.1 Create Team

```
TeamCreate(team_name="{team-name}")
```

### 4.2 Create Tasks

For each row in the Task Registry:

```
TaskCreate(
  subject="Task {step}: {title}",
  description=<Read FULL content of the file in File column>,
  metadata={"codeTaskFile": "{file_path}", "codeTaskStep": {step}},
  activeForm="Implementing {title}"
)
```

### 4.3 Map Dependencies

After ALL tasks are created, map step numbers to Agent Teams task IDs using the Task Registry.
For each task with Blocked-By entries:

```
TaskUpdate(taskId="{taskId}", addBlockedBy=[{blocked_by_task_ids}])
```

### 4.4 Spawn Initial Implementers

For each unblocked PENDING task (up to MAX_TEAMMATES concurrent):

```
Task(
  subagent_type="general-purpose",
  team_name="{team-name}",
  name="impl-{task-slug}",
  mode="bypassPermissions",
  model="{model}",
  prompt=<Section 7: Implementer Prompt below> + "\n\nYour assigned task ID: {taskId}"
)
```

## 5. Monitoring Protocol

**Role: PURE ORCHESTRATOR.** Read only 8-word summaries — never code, diffs, or full reviews.

**Tools allowed:**
- `TaskList` — task progress
- `TaskGet(taskId)` — task metadata (codeTaskFile, codeTaskStep)
- `Read(".ralph/guardrails.md")` — lessons accumulated by teammates
- `Read(".ralph/metrics.json")` — success/failure counts
- `Read(".ralph/failures.json")` — per-teammate failure tracking
- `SendMessage` — direct instructions to specific teammates

**If user asks to implement:** Redirect to teammates.

### State Machine — Pipeline Parallelism

**Internal state:** Maintain `tasks_in_review` — a set of taskIds whose implementation completed but review has not yet passed. Initialized empty at launch.

**Launchable task rule:** A task is launchable when ALL of these are true:
1. Unblocked in Agent Teams (no pending `blockedBy`)
2. None of its original `blockedBy` dependencies are in `tasks_in_review`
3. Active teammates < MAX_TEAMMATES

**WHEN implementer goes idle** — read 8-word summary from SendMessage:

**IF summary starts with "BLOCKED:":**
1. Send `shutdown_request` to the implementer
2. Read blockers.md from the task's step directory: `.ralph/specs/{goal}/implementation/{task_name}/blockers.md`
3. Surface blocker content to user. Do NOT spawn reviewer — wait for resolution.

**OTHERWISE (task completed, gates passed):**
1. Send `shutdown_request` to the implementer
2. Add taskId to `tasks_in_review`
3. Spawn reviewer for the completed task:

```
Task(
  subagent_type="general-purpose",
  team_name="{team-name}",
  name="rev-{task-slug}",
  mode="bypassPermissions",
  model="{model}",
  prompt=<Section 8: Reviewer Prompt below> + "\n\nYour assigned task ID: {taskId}\nTask file: {path_to_code_task_md}"
)
```

4. Check `TaskList` for launchable tasks. Spawn implementers up to MAX_TEAMMATES.

**WHEN reviewer goes idle** — read 8-word summary:

1. Send `shutdown_request` to the reviewer
2. **IF PASS**: Remove taskId from `tasks_in_review` → set `.code-task.md` `## Status: COMPLETED` + `## Completed: {date}` → check `TaskList` for launchable tasks → spawn implementers up to MAX_TEAMMATES
3. **IF FAIL**: taskId stays in `tasks_in_review` → spawn NEW implementer with review feedback:

```
Task(
  subagent_type="general-purpose",
  team_name="{team-name}",
  name="impl-{task-slug}-r{N}",
  mode="bypassPermissions",
  model="{model}",
  prompt=<Section 7: Implementer Prompt below> + "\n\nYour assigned task ID: {taskId}\nReview feedback: .ralph/reviews/task-{taskId}-review.md"
)
```

4. **IF BLOCKED**: Remove taskId from `tasks_in_review` → read `.ralph/reviews/task-{taskId}-blockers.md` → surface to user.

## 6. Completion

1. All tasks complete — all reviewers report PASS
2. Verify: all `.code-task.md` files have `Status: COMPLETED`
3. Send `shutdown_request` to any remaining teammates
4. `TeamDelete`
5. Report to user: "Ejecucion completa. {N} tasks completadas." + metrics summary from `.ralph/metrics.json`

## 7. Implementer Prompt

<!-- Inline full content of scripts/PROMPT_implementer.md here during generation -->

## 8. Reviewer Prompt

<!-- Inline full content of scripts/PROMPT_reviewer.md here during generation -->
